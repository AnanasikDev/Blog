[{"content":"I am Ananaseek or AnanseekJam - a young enthusiast with passion for game development, programming and art. Having embarked on my journey in 2020 Jan, I learned Python, C# + Unity, some C++, C and Java. I also led 2 teams on gamejams (Mini Jam #162 and #163).\nðŸ§Š-ed are freezed projects\nðŸ”¨-ed are projects in development\nðŸ”¥-ed are my favourite projects\nðŸ”’-ed are finished projects Games The Swap: EngageðŸ§ŠðŸ”¥ CompileðŸ”¥ðŸ”¥ðŸ”¨ Lolly JumpðŸ”¥ðŸ”’ UxClickerðŸ”¥ðŸ”’ OutlanderðŸ”’ Guns Vs Monsters (REMAKE) Space TimeðŸ§Š Fervent Longing (MiniJam #162)ðŸ”¥ðŸ”’ Tiny Kiosk (MiniJam #163)ðŸ§Š Recycle FactoryðŸ”’ Inevitable (UniverseJam #1)ðŸ”¥ðŸ”’ Libraries \u0026amp; Assets Willow AssetðŸ§ŠðŸ”¥ Hexagon LibraryðŸ”¥ðŸ”¨ FPS debuggerðŸ”’ EasyDebugðŸ”¥ðŸ”¨ Other File archivatorðŸ”’ Genetic algorithm learning to play Flappy BirdðŸ”¥ðŸ”’ CalculatorðŸ”’ Silly Minecraft mod Computer Vision racing controllerðŸ”¥ðŸ”’ 2D Game Engine + GameðŸ”¥ðŸ”’ Anti-anti-autoclickerðŸ”’ Brainfuck interpreterðŸ”¥ðŸ”’ Blender 3D model slicerðŸ”’ Genetic brain evolution simulationðŸ”’ I have also been contributing as a translator to other projects such as Hedy and Wild Assault. More about it at Weblate\nArticles:\nUnity: Islands Generator (2022-08) Software-Driven Devices: essay (2024-11) How to create a Minecraft server without hustle (2024-11) 3D models to real life figures (2025-08) Contact via Discord: Ananaseek#5568\nMy itch.io\nMy ArtStation\nMy models on CGTrader, Sketchfab and TurboSquid\n","date":"2021-06-18T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/about_me/cover_hu_86fcfac40107e269.jpg","permalink":"https://demo.stack.jimmycai.com/p/about_me/","title":"Hi thereðŸ‘‹"},{"content":"3D models to real life figures Today I want to share the process behind my latest DIY project: a cardboard tiger figure.\nFull code, blender file and usage instructions are available on Github.\nMotivation I have become a huge fan of large felines. As my obsession grows, I am searching for new ways to connect with their spirits. One such way is this 3D model, which now sits on my desktop.\nThe tiger is my favourite animal, slightly ahead of the cheetah and the leopard. Hopefully, I will be able to create models of them all, although the technology I am about to showcase in this article is rather tedious.\nPlan My plan was rendered as following:\nGet a 3D model to recreate Find a way to convert the model into an atlas Trace and cut out the pieces Glue all the pieces together Sounds like not much.\nStep #1: 3D model Even though I had experience in 3D sculpting in Blender (see Artstation), I wanted to focus more on bringing it to life, rather than making another virtual sculpt. So I found one online on blenderkit.\nStep #2: Atlas Having found a suitable model, I was then standing upon a real challenge: I had to find a way to convert it into slices of specific thickness so that I could trace individual pieces and then glue them together.\nI already had experience working with Blender and I didn\u0026rsquo;t mind getting more, so it was out of question what software to use. However, out of the box Blender doesn\u0026rsquo;t provide the functionality that I needed (obviously) so I had to come up with my own solution.\nFor that I wrote a python script to slice my model into pieces of specific thickness, essentially like MRT.\nFirst, the script calculates the positions and normals of all the planes that will be used to cut the model. The aim when cutting is to obtain a slice of geometry that corresponds to the intersection of the model and the cutting plane. This intersection, which is an edge loop, is then extruded and capped at both ends to create a single slice.\nNote that a single slice may consist of multiple physically unrelated pieces. In this case the script fills them independently as desired. This was necessary in my case because the middle layers contained several paws, and all the pieces had to be formed correctly.\nThis process it is then repeated as many times as needed to cover the entire model.\nIn Blender it looks like this:\nModel sliced in the Y axis\nModel sliced in the Z axis\nMoreover, since my plan was to trace all the pieces by hand (by placing a sheet of paper on a tablet) I added a mode to my script to automatically scatter all the pieces on a flat plane like so:\nThe checker pattern you see here is a special material I made that simulates correct physical size, using the scale value from the script that you initially set. One square represents exactly one centimeter.\nAt this point I had everything I needed to start the tedious manual work.\nStep #3: Trace and prepare Evenings got filled with tracing shapes over and over, then glueing paper and cardboard sheets, then cutting all pieces out.\nStep #4: Assembling Lastly, I had to glue all the pieces together. At this stage I realized that I miscalculated the thickness of my cardboard which appeared to be 1.5mm instead of 1mm thick. I compressed many of those pieces using anything heavy I had at home, and it helped. However I was inconsistent about which pieces I compress and which I do not, which resulted in a tilted model and nuances throughout the model.\nI had more than a hundred pieces so to simplify the process I made an indexation system: first number is the layer index (1-51) and second number is the piece index within its layer (none or 2-5).\nOriginally I wanted to strenthen the model with wooden sticks which would have become its framework. I cut out exact holes in the 3D model in Blender and transferred them into the final pieces. It looked promising, but in the end, I hesitated and decided not to use them though. This is one of the main mistakes, because the final figure appeared to be quite wobbly and weak.\nResult As a result, I now have this lovely physical model of my beloved tiger. Its dimensions are 170 x 104 x 46 mm.\nThanks for reading! ","date":"2025-08-13T00:00:00Z","image":"https://demo.stack.jimmycai.com/p/3d_to_real_life/images/cover_hu_8f8d915172904755.jpg","permalink":"https://demo.stack.jimmycai.com/p/3d_to_real_life/","title":"3D models to real life figures"},{"content":"How to setup your own minecraft server (Java, latest version, your hardware, free, official/hacked, online, ~20 players, safe) Disclaimer This is not an article but rather an instruction I made for myself to not forget how to setup a server. I was using Windows and doing that for cracked vanilla minecraft 1.21.3 so I can\u0026rsquo;t say if it\u0026rsquo;s working correctly in different conditions. It should generally be a universal approach as Java, Minecraft client and server, and Playit.gg have official ports to Linux and Mac (AFAIK).\nThis approach requires no use of console, no investments, you will have full control over your server. I listed pros and cons of it later in this note.\nSome of the tutorials/resources that I used:\nHost a Minecraft Server Without Port Forwarding Using Playit.gg \u0026ndash; video by KasaiSora Making your minecraft server public in 48 seconds without port forwarding \u0026ndash; video by playit How To Make A Cracked Minecraft Server (Any Version) \u0026ndash; video by KasaiSora How to Setup a Minecraft: Java Edition Server \u0026ndash; help.minecraft.nent How to create a Minecraft server for free! \u0026ndash; cyberxgaming.com Steps: Install Java You have to have Java of the version corresponding to your desired minecraft version (for 1.18+ it is Java 17, for 1.21+ it is Java 21 etc). You can check which version you need to have here.\nchoose and download your version on oracle website\nsimply download it, run installer, nothing more to do here\nOfficial minecraft server software Install minecraft official server setup software. It should be a file named server.jar downloaded from official minecraft page. AFAIK only the latest MC release is available here. For a simple setup you won\u0026rsquo;t need console and running commands as opposed to what\u0026rsquo;s said on that page.\nAlternatively, you may download it from other websites like mcversions where you can choose a specific version.\nDedicate a folder to the server files Put that server.jar file where you want to keep your server data. At this stage you should have a folder somewhere on your device where there is only that file.\nGenerate server files Run server.jar file by double clicking it, it\u0026rsquo;s java executable. In a few seconds it should generate a bunch of files around it (along with server.properties and eula.txt). If so, move straight to step 5. It might take around 10 seconds, but If you waited and nothing happened, you need to install jarfix (program to fix \u0026lsquo;java archive\u0026rsquo; execution issue on Windows) from here or here.\nTweak server settings First and foremost, you must open eula.txt and set eula to true, so that the whole file looks like this (with your date and time, of course):\n1 2 3 #By changing the setting below to TRUE you are indicating your agreement to our EULA (https://aka.ms/MinecraftEULA). #Mon Mar 11 13:11:52 CET 2024 eula=true Then, if you or your friends who you are planning to play with are using cracked minecraft, you also need to go to server.properties and change online-mode to false.\ndo not forget to save both files!\nIn the same server.properties you are also able to set difficulty, gamemode (including hardcore), max number of players, pvp, whitelist, generate structures and view distance along with other settings. I recommend to leave them default and play with them after succeeding in setting up the server to work correctly.\nRun server Run server.jar again, a GUI (a window) should appear (it might take some time). Your server is now up and running, but it\u0026rsquo;s only local, meaning that only you can join it. You still should test that everything is working by going to minecraft, multiplayer mode, direct connection and type in localhost or 127.0.0.1. If it returns an error, try restart your game AND launcher, restart the server and restart the PC. It might be giving errors at first but then begin working normally.\nSetup Playit.gg In order to make server public and open for other people, we need to setup a way for them to connect to your server.\nOne of the ways to do so is by using Playit.gg. Here is a concise tutorial by its developer (here is a reddit tread about it).\nIn a nutshell, you need to download Playit.gg from official website, create an account/login as a guest, then create a tunnel. When created, at the very bottom of the page there is a table with attributes and values, you need one called Allocation (Shared IP) (IP) OR Domain (Auto Assigned) (Domain) - you and anyone who wants to connect to your server will need either of these two.\nTry in minecraft Run minecraft (cracked or official) of the exact same version you created your server on step 1, go to multiplayer, direct connection/add server, put there IP:port from Playit.gg page from previous step OR domain. Click connect. The only thing you need to share with your friends for them to be able to join your server is either IP or domain, provided by Playit.gg.\nHow to run it / shut it down running Run server.jar, wait for it to launch. Run Playit.gg application installed on your PC, wait for it to launch. In minecraft, go to multiplayer, paste in your IP:host OR public domain of your server, auto assigned by Playit.gg, click connect.\nstopping To stop the server properly you need to shut down both Playit.gg app and server.jar app.\nIf getting errors on login If getting errors, check following:\nPlayit.gg AND server.jar are both running. Check their consoles for any errors Minecraft is of correct version (same as server) Internet connection is stable Java version is correct Check if localhost is working correctly. To do so, you won\u0026rsquo;t need Playit.gg, simply run server.jar and try to connect to it using localhost as described earlier in steps 1-6. If errors persist, try following:\nRestart game and launcher, server.jar, Playit.gg app and/or PC Disable and enable Playit.gg tunnel, try deleting it and creating a new one Pros/Cons Pros:\nCompletely free Safe (you do not share you own IP or open extra ports) Works on both official and cracked minecraft Can work with mods (search for a better instruction on that) Can handle up to 20 players by default You are using your own hardware for that (you can dedicate a lot of RAM and storage) All files are stored on your device, noone has control over them except for you, you can change settings etc You can create a whitelist and have control over connections Cons:\nMight be a bit problematic to setup Your device has to be running for the server to be running Your server will take storage space and resources of your device I could figure out how to create a server of non-latest version Other approaches to creating a Minecraft server Using hosts, like Scalacube (2.8GB, 6GB RAM for free - getting full very quickly) etc. Limited to storage space and RAM, but very easy to setup and use.\nUsing the same server.jar with port forwarding (less safe, more difficult to setup, needs access to your router).\nUsing LAN and Hamachi (not exactly a server but allows to play with friends). Might cause severe ping.\nMinecraft Realms. Paid and works only with official minecraft\n","date":"2024-11-27T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/how_to_make_a_minecraft_server/","title":"How to setup your own minecraft server"},{"content":"Software-Driven Devices in gaming In this essay, I want to discuss opportunities that computer vision (possibly in combination with other inputs) provides in gaming, how it can be implemented, describe several approaches to it and their benefits, and discuss the theoretical future of this technology.\nMy idea revolves around eliminating additional hardware accessories, leaving only a laptop, phone or tablet which are non-specific to gaming. Depending on the desired result, one may make marker-devices (MD for short) which are physical attributes one can use to play games.\nWhy? Hardware is expensive, inconvenient in transportation, difficult in distribution and modification, and barely sustainable in home conditions. In contrast, Software-Driven Devices (SDD for short) can be made at home; their price consists only of the cost of materials; and they are highly customizable.\nRacing setup What? The term \u0026ldquo;racing setup\u0026rdquo; here refers to devices one needs to play racing video games. Racing setups usually include a steering wheel, two or three pedals, and, in more expensive models, also gearbox, turn signals and other car controls. The most important parts of it that I will cover more profoundly in this essay are steering wheel and gas and brake pedals.\nHow? Generally, the idea behind SDD is in utilizing computer vision (through camera) as the only (or, at least, primary) source of input for a computer, eliminating need in any classical, hardware-driven-devices.\nSteering wheel The steering wheel has only one key property - angle. It can easily be detected by using special colored markers on the wheel for software to detect their positions and movement. By using several (at least three, theoretically) markers of different colors, sizes, or distances from the center evenly distributed along the circumference for better accuracy, steering wheel can rotate freely by 360 degrees without blind zones. If camera can capture the whole surface of the steering wheel without interruptions, then one marker should be enough; otherwise (if any objects obscure the visibility of some parts of the wheel) the method described above will help achieve identical result.\nTo calculate angle, computer also has to know center point of the steering wheel, which can be defined at calibration (more about it later).\nPedals A pedal has upper and lower limits and current value. Limits can be set at calibration, and current value can be calculated knowing position of the corresponding marker on the screen and size of the last.\nPedals are somewhat more creative in implementation than steering wheel. My approach was to hang a marker on a handle which can be moved up and down by pulling and releasing a string with your leg. This way I could achieve the best result both in terms of usability and accuracy and stability of results.\nPractical and theoretical advantages of SDDs in racing gaming 1.1 Near-zero cost of your SDDs\n1.2 Full customization of your controls\n1.3 Lightweight, simple to make, easy to take with you\n2.1 Usually provides acceptable or good control (for non-competitive gameplay) - can be improved\n2.2 Can use inputs from gestures and mimics (instead of or in addition to MDs)\nRequirements and limitations Computer vision strictly depends on lighting and camera quality. Standard laptop camera can capture 20-30 frames per second which might cause a delay which can be crucial when playing racing games. Can be solved by connecting a phone with better camera or an external camera.\nLighting should be bright and even. If lighting changes between gaming sessions, software should be recalibrated.\nSDDs in other spheres Animal gaming With SDD technologies animals can play video games naturally without using any hardware and adhering to physical constraints. Software could track animal\u0026rsquo;s movements and sounds and read them as an input.\nWith such unpredictable input however, SDDs might need not just computer vision but an AI component to it to analyze input more accurately (AI might increase accuracy with any SDDs).\nFighting, using magic wands etc Playing fighting games where you actually fight (with air, at least), dancing where you dance, using magic wands with real hand gestures and pronouncing spells is also possible using SDDs. Similar to VR, you can use your own body as an input device.\nNatural visual or audio inputs With computer monitoring player\u0026rsquo;s mimics, gestures, body movements and words, gaming might become more natural, with games receiving emotional feedback directly* rather than analyzing player actions and outcomes. It can suit highly emotional games like horrors, visual novels, (possibly new genres, revolving around emotional feedback from player) and so on with classic algorithms or AIs analyzing player\u0026rsquo;s emotions through camera and microphone and adjusting the game correspondingly.\n*mimics, eye movement and body language can reflect one\u0026rsquo;s mood better than actions in a game which are easier to control and less prone to emotional influence.\nOverall technology advantages 1.1 Near-zero cost of your SDDs\n1.2 Full customization of your controls\n1.3 Lightweight, simple to make, easy to take with you\n2.1 Usually provides acceptable or good control (for non-competitive gameplay)\n2.2 Can be extended to any kind of visual inputs (specific attributes, mimics, hand/body gestures, dance pad and so on) (might even eliminate need for any physical \u0026ldquo;devices\u0026rdquo;)\n2.3 Can be used by multiple users and animals\n2.4 Can be extended to be usable in non-racing games (VR with SDDs or other)\n3.1 Can give new gaming experience\nImplementation details Using bounding boxes for static or semi-static* inputs Dealing with computer-vision-based input, we should always contraint it to prevent ambiguous or wrong calculations. When setting up an input marker (steering wheel, pedal, buttons, triggers etc) we shall always (unless dealing with body inputs) define areas where it is located. This way, markers can share the same color scheme and still be unambiguous to the software as they are defined in different contexts.\n*semi-static inputs here refer to inputs which always adhere to same rules and whose properties can be predicted (e.g. a marker moving only vertically)\nUsing spectrum of colors Using contrast colors for markers and algorithms to analyze colors is crucial for accuracy and stability in CV-based SDDs. Acceptable color range depends on lighting conditions, camera quality, marker color and background color.\nWhen making a CV-based controller in Python, you can simply use numpy and cv2 libraries as following:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def detect_color_spots(hsv, lower_bound, upper_bound, area): # constrain inputs to color range mask = cv2.inRange(hsv, lower_bound, upper_bound) # constrain inputs to area mask = mask[area[0][1]:area[1][1], area[0][0]:area[1][0]] contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) if contours: # find largest contour found largest_contour = max(contours, key=cv2.contourArea) M = cv2.moments(largest_contour) # calculate center position if M[\u0026#34;m00\u0026#34;] != 0: cX = int(M[\u0026#34;m10\u0026#34;] / M[\u0026#34;m00\u0026#34;]) + area[0][0] cY = int(M[\u0026#34;m01\u0026#34;] / M[\u0026#34;m00\u0026#34;]) + area[0][1] return (cX, cY) return None and then find all spots of the given color range\n1 2 3 4 5 6 red_range = (np.array([100, 0, 0]), np.array([255, 120, 120])) spot_position = detect_color_spots(hsv, red_range[0], red_range[1], areas[\u0026#39;steering\u0026#39;]) if spot_position: # store the calculated position steering_spot_position = spot_position Calibration Calibration is necessary to adapt software to current lighting and setup. Calibration might include steps such as setting positions, default values, limits, defining areas, adjusting color sensitivity. It might be done automatically (when feedback is given by computer itself), semi-automatically (when user gives feedback) and manually (when user sets all values themselves).\nCalibration methods can be combined to achieve best accuracy and customization. In my racing setup I used semi-automatic approach for inferring steering wheel center and radius with user fixing these values by pressing certain keys on keyboard. This way, user can fine tune final values without doing tedious and prone-to-error calculations themselves.\nAfterthoughts It must have certainly been invented before me and I am sure games and technologies as I described and designed already exist, but they remain unknown to the public. I would love to see (and possibly make) this industry grow and thrive to let everyone feel gaming differently.\nI think playing games by actually moving your body, making gestures that mean something in the digital universe, talking to NPCs with your own voice can bring gaming to a whole new level. Gaming can become physically active, diverse, even more immersive and even more accessible.\nLess accessible but more immersive option I am thinking about is playing in front of a huge screen with camera put somewhere, when you can play bowling or fight with orcs or shoot a bow as flawlessly and seamlessly as it was real life or VR, but with no equipment and no risks.\nThis essay is inspired by one of my projects - Racing CV Controller (github link). I already wrote a post on reddit here but later I wanted to extend it with more general and detailed thoughts. I think it\u0026rsquo;s more than a joke project and one day it could bring a lot of joy and new good experience to people.\n","date":"2024-11-20T00:00:00Z","permalink":"https://demo.stack.jimmycai.com/p/no_hardware_racing_setup/","title":"How I made my own steering wheel using only my laptop"}]